#include <iostream>#include <unistd.h>#include <vector>#include "Point.h"#include "Strategy.h"#include "Judge.h"#define  INF 0x3f3f3f3f#define  WIN 999999#define  USER_L 2-ch    //user#define  MACH_L ch-1using namespace std;/*	策略函数接口,该函数被对抗平台调用,每次传入当前状态,要求输出你的落子点,该落子点必须是一个符合游戏规则的落子点,不然对抗平台会直接认为你的程序有误		input:		为了防止对对抗平台维护的数据造成更改，所有传入的参数均为const属性		M, N : 棋盘大小 M - 行数 N - 列数 均从0开始计， 左上角为坐标原点，行用x标记，列用y标记		top : 当前棋盘每一列列顶的实际位置. e.g. 第i列为空,则_top[i] == M, 第i列已满,则_top[i] == 0		_board : 棋盘的一维数组表示, 为了方便使用，在该函数刚开始处，我们已经将其转化为了二维数组board				你只需直接使用board即可，左上角为坐标原点，数组从[0][0]开始计(不是[1][1])				board[x][y]表示第x行、第y列的点(从0开始计)				board[x][y] == 0/1/2 分别对应(x,y)处 无落子/有用户的子/有程序的子,不可落子点处的值也为0		lastX, lastY : 对方上一次落子的位置, 你可能不需要该参数，也可能需要的不仅仅是对方一步的				落子位置，这时你可以在自己的程序中记录对方连续多步的落子位置，这完全取决于你自己的策略		noX, noY : 棋盘上的不可落子点(注:涫嫡饫锔?龅膖op已经替你处理了不可落子点，也就是说如果某一步				所落的子的上面恰是不可落子点，那么UI工程中的代码就已经将该列的top值又进行了一次减一操作，				所以在你的代码中也可以根本不使用noX和noY这两个参数，完全认为top数组就是当前每列的顶部即可,				当然如果你想使用lastX,lastY参数，有可能就要同时考虑noX和noY了)		以上参数实际上包含了当前状态(M N _top _board)以及历史信息(lastX lastY),你要做的就是在这些信息下给出尽可能明智的落子点	output:		你的落子点Point*/struct score{    int x,y,z;    score(int a,int b,int c){        x = a;y = b;z = c;    }};int cnt;vector<score>res;/*int vert_val[2][8] = {    {0,2,8,64,WIN,WIN,WIN,WIN},  //纵向权值 live    {0,1,4,32,WIN,WIN,WIN,WIN}   //die};int hori_val[2][8] ={    {0,4,16,128,WIN,WIN,WIN,WIN},  //横向权值 live    {0,3,12,96,WIN,WIN,WIN,WIN}     //die};int diag_val[2][8] ={    {0,4,16,128,WIN,WIN,WIN,WIN},  //对角权值 live    {0,3,12,96,WIN,WIN,WIN,WIN}       //die};*/const int MUL = 8;///defendint vert_val_d[4] = {0,1,4*MUL,4*MUL*MUL};int hori_val_d[4] = {0,1,4*MUL,4*MUL*MUL};int diag_val_d[4] = {0,1,4*MUL,4*MUL*MUL};///inte_valint inte_val[4] = {0,0,12,60};///attackint vert_val[2][2][9] = {    {        {0,1,int(2.4*MUL),int(2.8*MUL*MUL),WIN,WIN,WIN,WIN},  //纵向权值 live user        {0,1,int(2.3*MUL),int(2.5*MUL*MUL),WIN,WIN,WIN,WIN}      //die    },    {        {0,1,4*MUL,4*MUL*MUL,WIN,WIN,WIN,WIN},  //纵向权值 live  machine        {0,1,3*MUL,3*MUL*MUL,WIN,WIN,WIN,WIN}   //die    }};int hori_val[2][2][9] ={    {        {0,1,4*MUL,4*MUL*MUL,WIN,WIN,WIN,WIN},  //横向权值 live   user        {0,1,3*MUL,3*MUL*MUL,WIN,WIN,WIN,WIN}     //die    },    {        {0,1,4*MUL,4*MUL*MUL,WIN,WIN,WIN,WIN},  //横向权值 live   mach        {0,1,4*MUL,3*MUL*MUL,WIN,WIN,WIN,WIN}     //die    }};int diag_val[2][2][9] ={    {        {0,1,4*MUL,4*MUL*MUL,WIN,WIN,WIN,WIN},  //横向权值 live   user        {0,1,4*MUL,3*MUL*MUL,WIN,WIN,WIN,WIN}     //die    },    {        {0,1,4*MUL,4*MUL*MUL,WIN,WIN,WIN,WIN},  //横向权值 live   mach        {0,1,4*MUL,3*MUL*MUL,WIN,WIN,WIN,WIN}     //die    }};///敌方权值const double dec_rate = 0.9;int attack(int** board,int ch,int M,int N,int noX,int noY,int* top){    int sum = 0;    int idx = 0;    int tmp[20];        //Horizon    for(int i=0;i<M;i++){ // M行        idx = 0;        tmp[idx++] = -1; // 边界        for(int j=0;j<N;j++){  //N列            tmp[idx++] = board[i][j];        }        tmp[idx++] = -1;        for(int j=0;j<idx;j++){            if(tmp[j] == 3-ch || tmp[j] == -1 ){                int dd = min(j+5,idx);                int idx_ed = -1;                for(int k=j+1;k<dd;k++){  //如果j+1->j+4 有敌方棋子，那么这些位置不计分                    if(tmp[k] == 3-ch || tmp[k] == -1){                        idx_ed = k;                        break;                    }                }                if(idx_ed != -1){                    j = idx_ed;                }                continue;            }            int ed = j;            int st = j;            int max_step = min(j+3,idx);            int num_my = 0;            int dis_em = 0;            for(;ed < max_step ; ed++){ //往后4的范围内找有没有敌方棋子                if(tmp[ed] == 3-ch || tmp[ed] == -1){   //发现有敌人或者墙                    break;                }                if(tmp[ed] == ch)num_my++;                if(tmp[ed] == 0){                    dis_em += (top[ed-1] - i -1); //所在 行-1-top                    //printf("top:%d ,  i:%d\n",top[ed-1],i-1);                }            }            int flag=0;  //0 : all-live 2022  //1: half-live 12022  //2: die 12221            if(st == 0 || tmp[st-1] == 3-ch || tmp[st-1] == -1 ){  //墙 敌人  不可落                flag++;            }            if(ed == idx || tmp[ed] == 3-ch || tmp[ed] == -1 ){                flag++;            }            //printf("flag:%d\n",flag);            //printf("dis_em:%d\n",dis_em);            if(flag != 2){                int sum_tmp = hori_val[MACH_L][flag][num_my]; //ch-1 1:user 2:machine                while(dis_em){                    sum_tmp *= dec_rate;                    dis_em--;                }                sum += sum_tmp; //加flag            }        }    }        //vertical        for(int j=0;j<N;j++){  // 遍历列        idx = 0;        tmp[idx++] = -1; // 边界        for(int i = 0;i<M;i++){            tmp[idx++] = board[i][j];        }        tmp[idx++] = -1;        for(int i=0;i<idx;i++){            if(tmp[i] == 3-ch || tmp[i] == -1 ){                int dd = min(i+5,idx);                int idx_ed = -1;                for(int k=i+1;k<dd;k++){  //如果j+1->j+4 有敌方棋子，那么这些位置不计分                    if(tmp[k] == 3-ch || tmp[k] == -1 ){                        idx_ed = k;                        break;                    }                }                if(idx_ed != -1){                    i = idx_ed;                }                continue;            }            int ed = i;            int st = i;            int max_step = min(i+3,idx);            int num_my = 0;            for(;ed < max_step ; ed++){ //往后4的范围内找有没有敌方棋子                if(tmp[ed] == 3-ch||tmp[ed] == -1){   //发现有敌人                    break;                }                if(tmp[ed] == ch)num_my++;            }            int flag=0;  //0 : all-live 2022  //1: half-live 12022  //2: die 12221            if(st == 0 || tmp[st-1] == 3-ch || tmp[st-1] == -1 ){  //墙 敌人  不可落                flag++;            }            if(ed == idx || tmp[ed] == 3-ch || tmp[ed] == -1 ){                flag++;            }            if(flag != 2)                sum += vert_val[MACH_L][flag][num_my]; //加flag                    }    }                 //diag top-left -> bottom-right    for(int i=0;i<M;i++){ // M行        int st_x = i;        int st_y = 0;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(M-1-st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            tmp[idx++] = board[st_x+j][st_y+j];        }        tmp[idx++] = -1;        for(int j=0;j<idx;j++){            if(tmp[j] == 3-ch || tmp[j] == -1 ){                 int dd = min(j+5,idx);                 int idx_ed = -1;                 for(int k=j+1;k<dd;k++){  //如果j+1->j+4 有敌方棋子，那么这些位置不计分                     if(tmp[k] == 3-ch || tmp[k] == -1){                         idx_ed = k;                         break;                     }                 }                 if(idx_ed != -1){                     j = idx_ed;                 }                continue;            }            int ed = j;            int st = j;            int max_step = min(j+3,idx);            int num_my = 0;            int dis_em = 0;            for(;ed < max_step ; ed++){ //往后4的范围内找有没有敌方棋子                if(tmp[ed] == 3-ch || tmp[ed] == -1){   //发现有敌人                    break;                }                if(tmp[ed] == ch)num_my++;                if(tmp[ed] == 0)dis_em += (top[st_y+ed-1] - (st_x+ed-1)  -1);            }            int flag=0;  //0 : all-live 2022  //1: half-live 12022  //2: die 12221            if(st == 0 || tmp[st-1] == 3-ch || tmp[st-1] == -1 ){  //墙 敌人  不可落                flag++;            }            if(ed == idx || tmp[ed] == 3-ch || tmp[ed] == -1 ){                flag++;            }            if(flag != 2){                int sum_tmp = diag_val[MACH_L][flag][num_my];                while(dis_em){                    sum_tmp *= dec_rate;                    dis_em--;                }                sum += sum_tmp; //加flag            }        }    }        //上方对角线    for(int i=0;i<N;i++){ // M行        int st_x = 0;        int st_y = i;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(M-1-st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            tmp[idx++] = board[st_x+j][st_y+j];        }        tmp[idx++] = -1;        for(int j=0;j<idx;j++){            if(tmp[j] == 3-ch || tmp[j] == -1 ){                 int dd = min(j+5,idx);                 int idx_ed = -1;                 for(int k=j+1;k<dd;k++){  //如果j+1->j+4 有敌方棋子，那么这些位置不计分                     if(tmp[k] == 3-ch || tmp[k] == -1){                         idx_ed = k;                         break;                     }                 }                 if(idx_ed != -1){                     j = idx_ed;                 }                continue;            }            int ed = j;            int st = j;            int max_step = min(j+3,idx);            int num_my = 0;            int dis_em = 0;            for(;ed < max_step ; ed++){ //往后4的范围内找有没有敌方棋子                if(tmp[ed] == 3-ch || tmp[ed] == -1){   //发现有敌人                    break;                }                if(tmp[ed] == ch)num_my++;                if(tmp[ed] == 0)dis_em += (top[st_y+ed-1] - (st_x+ed-1) -1);            }            int flag=0;  //0 : all-live 2022  //1: half-live 12022  //2: die 12221            if(st == 0 || tmp[st-1] == 3-ch || tmp[st-1] == -1 ){  //墙 敌人  不可落                flag++;            }            if(ed == idx || tmp[ed] == 3-ch || tmp[ed] == -1 ){                flag++;            }            if(flag != 2){                int sum_tmp = diag_val[MACH_L][flag][num_my];                while(dis_em){                    sum_tmp *= dec_rate;                    dis_em--;                }                sum += sum_tmp; //加flag            }        }    }        //diag bottom-left -> top-right    for(int i=0;i<M;i++){ // M行        int st_x = i;        int st_y = 0;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            tmp[idx++] = board[st_x-j][st_y+j];        }        tmp[idx++] = -1;        for(int j=0;j<idx;j++){            if(tmp[j] == 3-ch || tmp[j] == -1 ){                 int dd = min(j+5,idx);                 int idx_ed = -1;                 for(int k=j+1;k<dd;k++){  //如果j+1->j+4 有敌方棋子，那么这些位置不计分                     if(tmp[k] == 3-ch || tmp[k] == -1){                         idx_ed = k;                         break;                     }                 }                 if(idx_ed != -1){                     j = idx_ed;                 }                continue;            }            int ed = j;            int st = j;            int max_step = min(j+3,idx);            int num_my = 0;            int dis_em = 0;            for(;ed < max_step ; ed++){ //往后4的范围内找有没有敌方棋子                if(tmp[ed] == 3-ch || tmp[ed] == -1){   //发现有敌人                    break;                }                if(tmp[ed] == ch)num_my++;                if(tmp[ed] == 0)dis_em += (top[st_y+(ed-1)] - (st_x-(ed-1)) -1  );            }            int flag=0;  //0 : all-live 2022  //1: half-live 12022  //2: die 12221            if(st == 0 || tmp[st-1] == 3-ch || tmp[st-1] == -1 ){  //墙 敌人  不可落                flag++;            }            if(ed == idx || tmp[ed] == 3-ch || tmp[ed] == -1 ){                flag++;            }            if(flag != 2){                int sum_tmp = diag_val[MACH_L][flag][num_my];                while(dis_em){                    sum_tmp *= dec_rate;                    dis_em--;                }                sum += sum_tmp; //加flag            } //               sum += diag_val[flag][num_my]; //加flag        }    }        for(int i=0;i<N;i++){ // M行        int st_x = M-1;        int st_y = i;        idx = 0;     tmp[idx++] = -1; // 边界        int max_it = min(st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            tmp[idx++] = board[st_x-j][st_y+j];        }        tmp[idx++] = -1;        for(int j=0;j<idx;j++){            if(tmp[j] == 3-ch || tmp[j] == -1 ){                 int dd = min(j+5,idx);                 int idx_ed = -1;                 for(int k=j+1;k<dd;k++){  //如果j+1->j+4 有敌方棋子，那么这些位置不计分                     if(tmp[k] == 3-ch || tmp[k] == -1){                         idx_ed = k;                         break;                     }                 }                 if(idx_ed != -1){                     j = idx_ed;                 }                continue;            }            int ed = j;            int st = j;            int max_step = min(j+3,idx);            int num_my = 0;            int dis_em = 0;            for(;ed < max_step ; ed++){ //往后4的范围内找有没有敌方棋子                if(tmp[ed] == 3-ch || tmp[ed] == -1){   //发现有敌人                    break;                }                if(tmp[ed] == ch)num_my++;                if(tmp[ed] == 0)dis_em += (top[st_y+(ed-1)] - (st_x-(ed-1))  -1);            }            int flag=0;  //0 : all-live 2022  //1: half-live 12022  //2: die 12221            if(st == 0 || tmp[st-1] == 3-ch || tmp[st-1] == -1 ){  //墙 敌人  不可落                flag++;            }            if(ed == idx || tmp[ed] == 3-ch || tmp[ed] == -1 ){                flag++;            }            if(flag != 2){                int sum_tmp = diag_val[MACH_L][flag][num_my];                while(dis_em){                    sum_tmp *= dec_rate;                    dis_em--;                }                sum += sum_tmp; //加flag            }                //sum += diag_val[flag][num_my]; //加flag        }    }         return sum;    }int defend_score(int** board,int ch,int M,int N,int noX,int noY,int* top){    int sum = 0;    int idx = 0;    int tmp[20];    //return 0;    //Horizon        for(int i=0;i<M;i++){ // M行        idx = 0;        tmp[idx++] = -1; // 边界        for(int j=0;j<N;j++){  //N列            if(board[i][j] == ch || board[i][j] == -1)                tmp[idx++] = j;        }        tmp[idx++] = N;        for(int j=0;j<idx-1;j++){            int st = tmp[j];            int ed = tmp[j+1];            int dis = ed-st-1;            if(1<=dis && dis<=3){                int num_d = 0;                int num_em = 0;                for(int k = st+1;k<ed;k++){                    if(board[i][k] == 3-ch){                        num_d++;                    }                    if(board[i][k] == 0){                        num_em += top[k] - i - 1;                    }                }                int sum_tmp = hori_val_d[num_d];                while(num_em){                    sum_tmp *= dec_rate;                    num_em--;                }                sum += sum_tmp;            }        }    }        //vertical        for(int j=0;j<N;j++){  // 遍历列        idx = 0;        tmp[idx++] = -1; // 边界        for(int i = 0;i<M;i++){            //tmp[idx++] = board[i][j];            if(board[i][j] == ch || board[i][j] == -1)                tmp[idx++] = i;        }        tmp[idx++] = M;        for(int i=0;i<idx-1;i++){            int st = tmp[i];            int ed = tmp[i+1];            int dis = ed-st-1;            if(1<=dis && dis<=3){                int num_d = 0;                for(int k=st+1;k<ed;k++){                    if(board[k][j] == 3-ch)num_d++;                }                sum += vert_val_d[num_d];            }        }    }             //diag top-left -> bottom-right    for(int i=0;i<M;i++){ // M行        int st_x = i;        int st_y = 0;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(M-1-st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            //tmp[idx++] = board[st_x+j][st_y+j];            if(board[st_x+j][st_y+j] == ch || board[st_x+j][st_y+j] == -1){                tmp[idx++] = j;            }        }        tmp[idx++] = max_it;        for(int j=0;j<idx-1;j++){            int st = tmp[j];            int ed = tmp[j+1];            int dis = ed-st-1;            if(1<=dis && dis<=3){                int num_d = 0;                int num_em = 0;                for(int k=st+1;k<ed;k++){                    if(board[st_x+k][st_y+k] == 3-ch)num_d++;                    if(board[st_x+k][st_y+k] == 0){                        num_em += top[st_y+k] - (st_x+k)-1;                    }                }                int sum_tmp = diag_val_d[num_d];                while(num_em){                    sum_tmp *= dec_rate;                    num_em--;                }                sum += sum_tmp;            }        }    }              //上方对角线    for(int i=0;i<N;i++){ // M行        int st_x = 0;        int st_y = i;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(M-1-st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            //tmp[idx++] = board[st_x+j][st_y+j];            if(board[st_x+j][st_y+j] == ch || board[st_x+j][st_y+j] == -1){                tmp[idx++] = j;            }        }        tmp[idx++] = max_it;        for(int j=0;j<idx-1;j++){            int st = tmp[j];            int ed = tmp[j+1];            int dis = ed-st-1;            if(1<=dis && dis<=3){                int num_d = 0;                int num_em = 0;                for(int k=st+1;k<ed;k++){                    if(board[st_x+k][st_y+k] == 3-ch)num_d++;                    if(board[st_x+k][st_y+k] == 0){                        num_em += top[st_y+k] - (st_x+k)-1;                    }                }                int sum_tmp = diag_val_d[num_d];                while(num_em){                    sum_tmp *= dec_rate;                    num_em--;                }                sum += sum_tmp;            }        }    }        //diag bottom-left -> top-right    for(int i=0;i<M;i++){ // M行        int st_x = i;        int st_y = 0;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            //tmp[idx++] = board[st_x-j][st_y+j];            if(board[st_x-j][st_y+j] == ch || board[st_x-j][st_y] == -1){                tmp[idx++] = j;            }        }        tmp[idx++] = max_it;        for(int j=0;j<idx-1;j++){            int st = tmp[j];            int ed = tmp[j+1];            int dis = ed-st-1;            if(1<=dis && dis<=3){                int num_d = 0;                int num_em = 0;                for(int k=st+1;k<ed;k++){                    if(board[st_x-k][st_y+k] == 3-ch)num_d++;                    if(board[st_x-k][st_y+k] == 0){                        num_em += top[st_y+k] - (st_x-k)-1;                    }                                    }                int sum_tmp = diag_val_d[num_d];                while(num_em){                    sum_tmp *= dec_rate;                    num_em--;                }                sum += sum_tmp;            }        }    }        for(int i=0;i<N;i++){ // M行        int st_x = M-1;        int st_y = i;        idx = 0;        tmp[idx++] = -1; // 边界        int max_it = min(st_x+1 , N-1-st_y+1);        for(int j=0;j<max_it;j++){  //N列            //tmp[idx++] = board[st_x-j][st_y+j];            if(board[st_x-j][st_y+j] == ch || board[st_x-j][st_y] == -1){                tmp[idx++] = j;            }        }        tmp[idx++] = max_it;        for(int j=0;j<idx-1;j++){            int st = tmp[j];            int ed = tmp[j+1];            int dis = ed-st-1;            if(1<=dis && dis<=3){                int num_d = 0;                int num_em = 0;                for(int k=st+1;k<ed;k++){                    if(board[st_x-k][st_y+k] == 3-ch)num_d++;                    if(board[st_x-k][st_y+k] == 0){                        num_em += top[st_y+k] - (st_x-k)-1;                    }                }                int sum_tmp = diag_val_d[num_d];                while(num_em){                    sum_tmp *= dec_rate;                    num_em--;                }                sum += sum_tmp;            }        }    }    return sum;    }int interrupt_bonus(const int x, const int y, const int M, const int N, int* const* board,int ch){    //return 0;    int sum = 0;    //横向检测    int i, j;    int count = 0;    for (i = y; i >= 0; i--)        if (!(board[x][i] == 3-ch))            break;    count += (y - i - 1);    for (i = y; i < N; i++)        if (!(board[x][i] == 3-ch))            break;    count += (i - y - 1);    if (1<=count && count<=3 ) sum += inte_val[count];    //纵向检测    count = 0;    for (i = x; i < M; i++)        if (!(board[i][y] == 3-ch))            break;    count += (i - x - 1);        for(i=x-1;i>=0;i--)        if(!(board[i][y] == 3-ch))            break;        else count++;    if (1<=count && count<=3 ) sum += inte_val[count];    //左下-右上    count = 0;    for (i = x, j = y; i < M && j >= 0; i++, j--)        if (!(board[i][j] == 3-ch))            break;    count += (y - j - 1);    for (i = x, j = y; i >= 0 && j < N; i--, j++)        if (!(board[i][j] == 3-ch))            break;    count += (j - y - 1);    if (1<=count && count<=3 ) sum += inte_val[count];    //左上-右下    count = 0;    for (i = x, j = y; i >= 0 && j >= 0; i--, j--)        if (!(board[i][j] == 3-ch))            break;    count += (y - j-1);    for (i = x, j = y; i < M && j < N; i++, j++)        if (!(board[i][j] == 3-ch))            break;    count += (j - y - 1);    if (1<=count && count<=3 ) sum += inte_val[count];    return sum;}int interrupt(int** board,int ch,int M,int N,int noX,int noY,int* top){        int sum = 0;    for(int i=0;i<M;i++){        for(int j=0;j<N;j++){            if(board[i][j] == ch){                sum += interrupt_bonus(i,j,M,N,board,ch);            }        }    }    return sum;}int evaluate(int ** board,int M,int N,int noX,int noY,int* top){ ///考虑最后一步该谁下    //return 0;    int my_score = 0,machine_score = 0;    my_score = attack(board,2,M,N,noX,noY,top);//进攻得分    machine_score = attack(board,1,M,N,noX,noY,top);        my_score += defend_score(board,2,M,N,noX,noY,top);//防守得分    machine_score += defend_score(board,1,M,N,noX,noY,top);        //my_score += interrupt(board,2,M,N,noX,noY,top);//截断得分    //machine_score += interrupt(board,1,M,N,noX,noY,top);    return my_score - machine_score;}int ret_x,ret_y;int alhpabeta(int n,int depth,int alpha,int beta,int** board,int * top,int M,int N,int noX,int noY){        bool has_emp = 0;   //有没有空位    for(int i=0;i<N;i++){        if(top[i] != 0)has_emp = 1;    }    if(n == depth || (!has_emp) ){        //printf("eva : %d\n", evaluate(board,M,N,noX,noY));        return evaluate(board,M,N,noX,noY,top);    }    int value;    if(n&1){  //极大值点        value = -INF;        for(int i=0;i<N;i++){  // M个可落子点            int pos = top[i]-1;            if(pos < 0)continue; //本列没有位置                        int ori = board[pos][i];                        board[pos][i] = 2;            top[i]--;            if(top[i]-1 == noX && i == noY)top[i]--; //不可落子                        if(machineWin(pos, i, M, N, board)){                if(n == 1){                    ret_x = pos,                    ret_y = i;                }                if(top[i] == noX && i == noY)top[i]++; //不可落子                int pos_n = top[i];                top[i]++;                board[pos_n][i] = ori;                                                return WIN;            }            //改棋盘            int ret_val = alhpabeta(n+1, depth, alpha, beta, board, top,M,N,noX,noY);            if(ret_val > value){                value = ret_val;                if(n == 1){                    ret_x = pos,                    ret_y = i;                }            }            /*            if(n==1){                printf("%d * ",ret_val);            }*/            alpha = max(alpha,value);            //恢复棋盘                        if(top[i] == noX && i == noY)top[i]++; //不可落子            int pos_n = top[i];            top[i]++;            board[pos_n][i] = ori;                    }        //if(n==1)printf("\n");    }    else{     //极小值点        //printf("111\n");        value = INF;        for(int i=0;i<N;i++){ // M个可落子点            int pos = top[i]-1;            if(pos < 0)continue; //本列没有位置                        int ori = board[pos][i];                        board[pos][i] = 1;            top[i]--;            if(top[i]-1 == noX && i == noY)top[i]--; //不可落子                        if(userWin(pos, i, M, N, board)){                if(top[i] == noX && i == noY)top[i]++; //不可落子                int pos_n = top[i];                top[i]++;                board[pos_n][i] = ori;                //printf("n:%d value:%d\n",n,-WIN);                return -WIN;            }            //改棋盘            value = min(value,alhpabeta(n+1, depth, alpha, beta, board, top,M,N,noX,noY));            beta = min(beta , value);            //恢复棋盘                        if(top[i] == noX && i == noY)top[i]++; //不可落子            int pos_n = top[i];            top[i]++;            board[pos_n][i] = ori;        }    }    //printf("n:%d value:%d\n",n,value);    return  value;}extern "C" Point* getPoint(const int M, const int N, const int* top, const int* _board, 	const int lastX, const int lastY, const int noX, const int noY){	/*		不要更改这段代码	*/	int x = -1, y = -1;//最终将你的落子点存到x,y中	int** board = new int*[M];	for(int i = 0; i < M; i++){		board[i] = new int[N];		for(int j = 0; j < N; j++){			board[i][j] = _board[i * N + j];		}	}    	/*		根据你自己的策略来返回落子点,也就是根据你的策略完成对x,y的赋值		该部分对参数使用没有限制，为了方便实现，你可以定义自己新的类、.h文件、.cpp文件	*/	//Add your own code below //naive   /* for (int i = N-1; i >= 0; i--) {            if (top[i] > 0) {                x = top[i] - 1;                y = i;                break;            }        }    clearArray(M, N, board);        return new Point(x, y);*/    int* top_c = (int*) malloc(N*sizeof(int));    for(int i=0;i<N;i++){        top_c[i] = top[i];    }    int cnt1 = 0,cnt2 = 0;    for(int i=0;i<M;i++){        for(int j=1;j<=N;j++){            if(board[i][j] == 1)cnt1++;            if(board[i][j] == 2)cnt2++;        }    }    if(cnt1 == 1 && cnt2 == 0)cnt = 1;        if(lastX < 0 || lastX >= M || lastY < 0 || lastY >= N){  //先手  第一次落子 落中间        int col = N/2;        int row = top_c[col]-1;        top_c[col]--;        if(col == noY && top_c[col]-1 == noX)            top_c[col]--;        //printf("%d : (%d,%d) \n",cnt,row,col);        return  new Point(row,col);            }    else if(cnt == 1){ //后手 第一次        cnt = 0;        int dis1 = lastY;  // 放在位置多的一侧  或者中间        int dis2 = N-lastY-1;        int col ,row;        if(dis1 > dis2){            col = lastY - 1;        }        else{            col = lastY + 1;        }        row = top_c[col]-1;                int col_half = N/2;   //中间的位置        int row_half = top_c[col_half]-1;                int rd = rand();  //概率选择        if(rd&1){            top_c[col]--;            if(col == noY && top_c[col]-1 == noX)                top_c[col]--;            return new Point(row,col);        }        else{            top_c[col_half]--;            if(col_half == noY && top_c[col_half]-1 == noX)                top_c[col_half]--;            return new Point(row,col);        }        //printf("%d : (%d,%d) \n",cnt,row,col);        }        res.clear();    board[noX][noY] = -1; // 不可落子点        int ret_s = alhpabeta(1,5,-INF,INF,board,top_c,M,N,noX,noY); // 当前层,预测深度,a,b,board,top,M,N        if(ret_s == -WIN){//必输别乱下        bool fd = 0;        int max_sc = -WIN;        for(int i=0;i<N;i++){            if(top[i]==0)continue;            int x_tmp = top[i]-1;            int y_tmp = i;            board[x_tmp][y_tmp] = 1;            if(userWin(x_tmp, y_tmp, M, N, board)){                x = x_tmp;y = y_tmp;                fd = 1;                break;            }            board[x_tmp][y_tmp] = 0;        }        if(!fd){            for(int i=0;i<N;i++){                int pos = top[i]-1;                if(pos < 0)continue; //本列没有位置                                int ori = board[pos][i];                                board[pos][i] = 2;                top_c[i]--;                if(top[i]-1 == noX && i == noY)top_c[i]--; //不可落子                int score =evaluate(board, M, N, noX, noY, top_c);                if(score > max_sc){                    max_sc = score;                    x = pos;                    y = i;                }                //恢复棋盘                                if(top_c[i] == noX && i == noY)top_c[i]++; //不可落子                int pos_n = top_c[i];                top_c[i]++;                board[pos_n][i] = ori;            }        }    }    else{        x = ret_x;        y = ret_y;    }    /*    for(int i=0;i<M;i++){        for(int j=0;j<N;j++){            printf("%2d ",board[i][j]);        }        printf("\n");    }    printf("----\n");    printf("pro2 : %d\n",attack(board,2,M,N,noX,noY,top_c));    printf("pro1 : %d\n",attack(board,1,M,N,noX,noY,top_c));    for(int i=0;i<N;i++){        printf("%d-",top[i]);    }    printf("\n");    printf("%d,%d\n",x,y);    printf("\n\n\n");    */		/*		不要更改这段代码	*/	clearArray(M, N, board);	return new Point(x, y);}/*	getPoint函数返回的Point指针是在本dll模块中声明的，为避免产生堆错误，应在外部调用本dll中的	函数来释放空间，而不应该在外部直接delete*/extern "C" void clearPoint(Point* p){	delete p;	return;}/*	清除top和board数组*/void clearArray(int M, int N, int** board){	for(int i = 0; i < M; i++){		delete[] board[i];	}	delete[] board;}/*	添加你自己的辅助函数，你可以声明自己的类、函数，添加新的.h .cpp文件来辅助实现你的想法*/